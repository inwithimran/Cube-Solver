import React, { Component } from 'react';
import Navbar from "./components/Navbar/Navbar";
import * as THREE from "three";
import './App.css';
import 'bootstrap/dist/css/bootstrap.min.css';
import 'bootstrap';

class App extends Component {
  state = {
    cubes : [],           // Contains visual cube
    rubiksObject : [],      // Contains memory cube
    speed : 10,           // Control individual piece rotation speed (don't change)
    rotationSpeed : 250,  // Controls visual rotation speed
    canScramble: true,    // Manual rotations can't happen while this is false
    canMove: true,
    start : 10,           // Start value for a rotation or set of rotations
    end : 0,              // End value for a roation or set of rotations
    turnDirection : 0,    // Dictates whether the rotation is clockwise or counterclockwise
    face : 0,             // The face being turned
    cameraX : 10,
    cameraY : -10,
    cameraZ : 10,
    theta : 5,
    currentFunc : "None",
    moveLog : "",
    reversing : false,
    angle : 3.9,
    cubeDimension : 10,
    cubeDepth : 1
  };

  // Generates the inital solved state of rubiksObject
  generateSolved = (_x,_y,_z) =>{
    let tempArr = [];
    for(let j = 0; j < _y; j++){
      for(let k = _z-1; k >= 0; k--){
        for(let i = 0; i < _x; i++){
          let side0 = "black";
          let side1 = "black";
          let side2 = "black";
          let side3 = "black";
          let side4 = "black";
          let side5 = "black";
          if(i===_x-1) side2 = "red";
          else if (i===0) side4 ="orange";
          if(j===_y-1) side3 = "yellow";
          else if (j===0) side0 ="white";
          if(k===_z-1) side1 = "blue";
          else if (k===0) side5 ="green";
          tempArr.push([side0,side1,side2,side3,side4,side5,i,j,k]);
        }
      }
    }
    return tempArr;
  }

  // For visual cube
  rotatePoint = (c1,c2,direction,p1,p2,rotation) =>{
    let theta = rotation*Math.PI/180;
    if(direction < 0) theta*=-1; 
    return { p1 : (Math.cos(theta) * (p1-c1) - Math.sin(theta) * (p2-c2) + c1),
             p2 :   (Math.sin(theta) * (p1-c1) + Math.cos(theta) * (p2-c2) + c2)}
  }

  // For memory cube
  rotatePoint2 = (c1,c2,direction,p1,p2) =>{
    let theta = Math.PI/2;
    if(direction < 0) theta*=-1; 
    return { p1 : (- Math.sin(theta) * (p2-c2) + c1),
             p2 :   (Math.sin(theta) * (p1-c1) + c2)}
  }

  // rotate colors on face
  rotateFace = (cubeFace,direction,cubeDepth) => {
    let centerPoint = this.state.cubeDimension/2-.5;
    let rubiksObject = this.state.rubiksObject;
    let degrees = 90;

    if(direction < 0)  degrees *=-1;

    // Side 0 (white center piece)
    if (cubeFace === 0){
        for(let i = 0; i < rubiksObject.length; i++){

            // white side is y===0
            if (rubiksObject[i][7] > -1 && rubiksObject[i][7] < cubeDepth){

                // Rotate rubiksObject pieces to new location generated by rotatePoint2
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][6],rubiksObject[i][8]);
                rubiksObject[i][6] = newPoint.p1;
                rubiksObject[i][8] = newPoint.p2;

                // Unfortunately chunky
                // Swaps colors around on the face to match rotations
                if(direction === 0){
                    let tempFace = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][2];
                    rubiksObject[i][2] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][4];
                    rubiksObject[i][4] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][4];
                    rubiksObject[i][4] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][2];
                    rubiksObject[i][2] = tempFace;
                }
            }
        }
    }

    // Side 1 (blue center piece)
    if (cubeFace === 1){
        for(let i = 0; i < rubiksObject.length; i++){
            if (rubiksObject[i][8] < this.state.cubeDimension && rubiksObject[i][8]>this.state.cubeDimension-1-cubeDepth){
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][6],rubiksObject[i][7]);
                rubiksObject[i][6] = newPoint.p1;
                rubiksObject[i][7] = newPoint.p2;
                if(direction === 0){
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][2];
                    rubiksObject[i][2] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][4];
                    rubiksObject[i][4] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][4];
                    rubiksObject[i][4] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][2];
                    rubiksObject[i][2] = tempFace;
                }
            }
        }
    }
    
    // Side 2 (red center piece)
    if (cubeFace === 2){
        for(let i = 0; i < rubiksObject.length; i++){
            if (rubiksObject[i][6] < this.state.cubeDimension && rubiksObject[i][6]>this.state.cubeDimension-1-cubeDepth){
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][7],rubiksObject[i][8]);
                rubiksObject[i][7] = newPoint.p1;
                rubiksObject[i][8] = newPoint.p2;
                if(direction === 0){
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][1];
                    rubiksObject[i][1] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][5];
                    rubiksObject[i][5] = tempFace;
                }
            }
        }
    }
    
    // Side 3 (yellow center piece)
    if (cubeFace === 3){
        for(let i = 0; i < rubiksObject.length; i++){
            if (rubiksObject[i][7] < this.state.cubeDimension && rubiksObject[i][7]>this.state.cubeDimension-1-cubeDepth){
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][6],rubiksObject[i][8]);
                rubiksObject[i][6] = newPoint.p1;
                rubiksObject[i][8] = newPoint.p2;
                if(direction === -1){
                    let tempFace = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][4];
                    rubiksObject[i][4] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][2];
                    rubiksObject[i][2] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][2];
                    rubiksObject[i][2] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][4];
                    rubiksObject[i][4] = tempFace;
                }
            }
        }
    }

    // Side 4 (orange center piece)
    if (cubeFace === 4){
        for(let i = 0; i < rubiksObject.length; i++){
            if (rubiksObject[i][6] > -1 && rubiksObject[i][6] < cubeDepth){
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][7],rubiksObject[i][8]);
                rubiksObject[i][7] = newPoint.p1;
                rubiksObject[i][8] = newPoint.p2;
                if(direction === -1){
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][1];
                    rubiksObject[i][1] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][5];
                    rubiksObject[i][5] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][5];
                    rubiksObject[i][5] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][1];
                    rubiksObject[i][1] = tempFace;
                }
            }
        } 
    }

    // Side 5 (green center piece)
    if (cubeFace === 5){
        for(let i = 0; i < rubiksObject.length; i++){
            if (rubiksObject[i][8] > -1 && rubiksObject[i][8] < cubeDepth){
                let newPoint = this.rotatePoint2(centerPoint,centerPoint,degrees,rubiksObject[i][6],rubiksObject[i][7]);
                rubiksObject[i][6] = newPoint.p1;
                rubiksObject[i][7] = newPoint.p2;
                if(direction === -1){
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][4];
                    rubiksObject[i][4] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][2];
                    rubiksObject[i][2] = tempFace;
                } else {
                    let tempFace = rubiksObject[i][3];
                    rubiksObject[i][3] = rubiksObject[i][2];
                    rubiksObject[i][2] = rubiksObject[i][0];
                    rubiksObject[i][0] = rubiksObject[i][4];
                    rubiksObject[i][4] = tempFace;
                }
            }
        } 
    }

    this.setState({rubiksObject : rubiksObject}, () =>{

      let reloadCubes = this.reloadCubes;
      let rotationSpeed = this.state.rotationSpeed;
      let moveOn = this.moveOn;
      let scope = this;
      let canMove = this.state.canMove;

      // Necessary to keep rendering conflicts from happening
      setTimeout(function () {
        if(!canMove) scope.setState({currentFunc: "None"});
        reloadCubes();
        moveOn();
      }, rotationSpeed);
    });
    
  };

  // Needs a bit of work
  decreaseSpeed = () => {
    if(this.state.rotationSpeed<1000){
      this.setState({rotationSpeed : this.state.rotationSpeed+50});
    }
  }

  // Needs a bit of work
  increaseSpeed = () => {
    if(this.state.rotationSpeed>200){
      this.setState({rotationSpeed : this.state.rotationSpeed-50});
    }
  }

  rotateCamera = (key) => {
    let y = this.state.cameraY;

    if(key === 37){ // left
      this.setState({angle: this.state.angle+.2}); 
    }
    if(key === 38){ // up
      if(y < 7.5) this.setState({cameraY: y + 2});
    }
    if(key === 39){ // right
      this.setState({angle: this.state.angle-.2});
    }
    if(key === 40){ // down
      if(y > -7.5) this.setState({cameraY: y - 2});
    }
  }

  keyHandling = e => {
    this.rotateCamera(e.keyCode);
  }

  // Control when rotation buttons can be clicked
  rzl = () => {
    if(this.state.canScramble && this.state.canMove) {
      this.setState({currentFunc: "F'"});
      this.rotateCubeFace(0,0,1);
    }
  }
  rzr = () => {
    if(this.state.canScramble && this.state.canMove) {
      this.setState({currentFunc: "F"});
      this.rotateCubeFace(0,-1,1);
    }
  }

  rol = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(1,0,1);}
  ror = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(1,-1,1);}

  rtwl = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(2,0,1);}
  rtwr = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(2,-1,1);}

  rthl = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(3,0,1);}
  rthr = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(3,-1,1);}

  rfol = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(4,0,1);}
  rfor = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(4,-1,1);}

  rfil = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(5,0,1);}
  rfir = () => {if(this.state.canScramble && this.state.canMove) this.rotateCubeFace(5,-1,1);}

  // Changes values in state to trigger face rotation
  rotateCubeFace = (face,direction,cubeDepth) => {
    if(!this.state.reversing){
      let tempMove = "";
      if(cubeDepth<10) tempMove+="0"+cubeDepth;
      else tempMove += cubeDepth;
      if(face === 0) tempMove += "F";
      else if(face === 1) tempMove += "U";
      else if(face === 2) tempMove += "R";
      else if(face === 3) tempMove += "B";
      else if(face === 4) tempMove += "L";
      else if(face === 5) tempMove += "D";
      if(direction === -1) tempMove += "'";
      if(this.state.moveLog.length > 0)
        this.setState({moveLog : this.state.moveLog + " " + tempMove});
      else
        this.setState({moveLog : this.state.moveLog + tempMove});
    }

    if(this.state.canScramble) this.moveOff();

    // Faces on opposite side of cube rotate backwards
    if(face>2 && direction === -1) direction = 0;

    else if (face>2 && direction === 0) direction = -1;

    // change state so animate function kicks in
    this.setState({face : face,
                   turnDirection : direction,
                   end : this.state.end + 90,
                   cubeDepth : cubeDepth},
                   () =>{
      this.rotateFace(face,direction,cubeDepth);
    });
  }

  scrambleOn = () => {
    this.setState({canScramble : true});
  }

  scrambleOff = () => {
    this.setState({canScramble : false});
  }

  moveOn = () => {
    this.setState({canMove : true});
  }

  moveOff = () => {
    this.setState({canMove : false});
  }

  // Slows the scramble function down to keep from breaking the cube
  // Consider removing this and using moveSetTimed
  timingScramble = iteration => {

    // put variables in scope of setTimeout
    let rotateCubeFace = this.rotateCubeFace;
    let timingScramble = this.timingScramble;
    let scrambleOn = this.scrambleOn;
    let rotationSpeed = this.state.rotationSpeed;
    let scope = this;
    // use recursion with a timeout to prevent turns from overlapping
    if(iteration>0)
      setTimeout(function () {
        let maxDepth = Math.floor((scope.state.cubeDimension/2));
        let randFace = Math.floor((Math.random() * 6));
        let randTurn = Math.floor((Math.random() * 2)-1);
        let randDepth = 1;
        if(scope.state.cubeDimension>3) 
          randDepth = Math.floor((Math.random() * maxDepth)) + 1;
        rotateCubeFace(randFace, randTurn,randDepth);
        timingScramble(iteration-1);
      }, rotationSpeed);

    else {
      setTimeout(function () {
        scope.setState({currentFunc: "None"});
        scrambleOn();
      }, rotationSpeed);
    }
  }

  // Converts move string to move array
  moveStringToArray = str => {
    let tempArray = str.split(" ");
    let moveArray = [];

    // Run through split string and create duplicates where needed
    for(let i = 0; i < tempArray.length;i++){
      if(tempArray[i].length === 4 && tempArray[i].slice(3,4)==="2") {
        let tempMove = tempArray[i].slice(0,3);
        moveArray.push(tempMove);
        moveArray.push(tempMove);
      }
      else {
        moveArray.push(tempArray[i]);
      }
    }
    return moveArray;
  }

  // Algorithm for Checkerboard
  checkerBoard = () => {
    let moveString = "01U2 01D2 01R2 01L2 01F2 01B2";
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Checkerboard"});

    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Algorithm for Checkerboard1
  checkerBoard1 = () => {
    let moveString = "01U' 01R2 01L2 01F2 01B2 01U' 01R 01L 01F 01B' 01U 01F2 01D2 01R2 01L2 01F2 01U2 01F2 01U' 01F2";
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Checkboard1"});
  
    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Algorithm for Cube in a cube in a cube
  cubeInACube = () => {
    let moveString = "01U' 01L' 01U' 01F' 01R2 01B' 01R 01F 01U 01B2 01U 01B' 01L 01U' 01F 01U 01R 01F'"
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Cube x3"});

    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Algorithm for Cube in a cube
  cubeIn = () => {
    let moveString = "01F 01L 01F 01U' 01R 01U 01F2 01L2 01U' 01L' 01B 01D' 01B' 01L2 01U";
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Cube x2"});

    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Algorithm for isolating middles
  sixSpots = () => {
    let moveString = "01U 01D' 01R 01L' 01F 01B' 01U 01D'"
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Six Spots"});

    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Algorithm for coss
  cross = () => {
    let moveString = "01R2 01L' 01D 01F2 01R' 01D' 01R' 01L 01U' 01D 01R 01D 01B2 01R' 01U 01D2";
    const moveArray = this.moveStringToArray(moveString);
    this.setState({currentFunc : "Cross"});
    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
  }

  // Generalized time move function. Takes in move array and creates small delay between moves
  moveSetTimed = (moveArray,length, start, solving) =>{

    // Breaks at faster speeds
    if(this.state.rotationSpeed < 200)
      this.setState({rotationSpeed: 200});

    if(start === 0)
      this.setState({canScramble : false});

    let tempFace = 0;
    let tempDirection = -1;
    let tempDepth = 1;
    if(start <= length){
      if(moveArray[start].length === 4) tempDirection=0;
      tempDepth = parseInt(moveArray[start].slice(0,2));

      if(moveArray[start].slice(2,3) === "U") tempFace = 1;
      else if(moveArray[start].slice(2,3) === "F") tempFace = 0;
      else if(moveArray[start].slice(2,3) === "B") tempFace = 3;
      else if(moveArray[start].slice(2,3) === "R") tempFace = 2;
      else if(moveArray[start].slice(2,3) === "L") tempFace = 4;
      else if(moveArray[start].slice(2,3) === "D") tempFace = 5;
    }

    let rotateCubeFace = this.rotateCubeFace;
    let moveSetTimed = this.moveSetTimed;

    setTimeout(function () {
      if(start <= length) {
        rotateCubeFace(tempFace,tempDirection,tempDepth);
      }
      start = start + 1;
      moveSetTimed(moveArray,length,start,solving);
    }, this.state.rotationSpeed);

    
    if(start === length+1) {
      this.setState({currentFunc : "None"});
      this.setState({canScramble : true});

      // required for functions to be in scope of setTimeout
      let solveWhiteCross = this.solveWhiteCross;
      let solveWhiteCorners = this.solveWhiteCorners;
      let solveMiddleEdges = this.solveMiddleEdges;
      let solveYellowCross = this.solveYellowCross;
      let alignYellowCross = this.alignYellowCross;
      let alignYellowCorners = this.alignYellowCorners;
      let solveYellowCorners = this.solveYellowCorners;

      // required for this to be in scope of setTimeout
      let scope = this;

      // Check if move set is part of the solve functions
      if(solving === 1) setTimeout(function () {solveWhiteCross();}, 50);
      else if(solving === 2 ) setTimeout(function () {solveWhiteCorners();}, 50);
      else if(solving === 3 ) setTimeout(function () {solveMiddleEdges();}, 50);
      else if(solving === 4)  setTimeout(function () {solveYellowCross();}, 50);
      else if(solving === 5)  setTimeout(function () {alignYellowCross();}, 50);
      else if(solving === 6)  setTimeout(function () {alignYellowCorners();}, 50);
      else if(solving === 7)  setTimeout(function () {solveYellowCorners(scope);}, 50);
    }
  }

  // Scrambles the cube
  scramble = () => {
    if(this.state.canScramble){
      this.setState({currentFunc : "Scrambling"});
      this.setState({canScramble : false});
      this.timingScramble(25);
    }
  }

  // Rewinds all moves that have been done to the cube since unsolved state
  // Add in solved array to compare for when the cube becomes solved
  reverseMoves = () => {
    if(this.state.reversing===true || !this.state.canScramble) return;
    
    console.log(this.state.moveLog);
    if(!this.state.moveLog.length) return;
    this.setState({reversing : true});
    let moveString = this.state.moveLog;
    this.setState({moveLog : ""});
    this.setState({currentFunc : "Reverse Moves"});

    const tempArray = this.moveStringToArray(moveString);
    const moveArray = [];

    for(let i = tempArray.length-1; i >= 0; i--){
      moveArray.push(tempArray[i]);
    }
    
    if(this.state.canScramble){
      this.moveSetTimed(moveArray,moveArray.length-1,0,0);
    }
    
    return moveArray.length;
  }

  // Refreshes page to reset cube
  reset = () => {
    window.location.reload();
  }

  // Incase of rendering conflicts, reload cube color positions
  reloadCubes = () => {
    let cubes = [...this.state.cubes];
    
    for(let i = 0; i<this.state.rubiksObject.length;i++){
      let cube = {...cubes[i]};
      if((this.state.cubes[i].position.x === 0 || this.state.cubes[i].position.x === this.state.cubeDimension-1) ||
            (this.state.cubes[i].position.y === 0 || this.state.cubes[i].position.y === this.state.cubeDimension-1)||
            (this.state.cubes[i].position.z === 0 || this.state.cubes[i].position.z === this.state.cubeDimension-1)){
      cube.material[0].color = new THREE.Color(this.state.rubiksObject[i][2]);
      cube.material[1].color = new THREE.Color(this.state.rubiksObject[i][4]);
      cube.material[2].color = new THREE.Color(this.state.rubiksObject[i][3]);
      cube.material[3].color = new THREE.Color(this.state.rubiksObject[i][0]);
      cube.material[4].color = new THREE.Color(this.state.rubiksObject[i][1]);
      cube.material[5].color = new THREE.Color(this.state.rubiksObject[i][5]);
      cube.rotation.x = 0; cube.rotation.y = 0; cube.rotation.z = 0;
      cubes[i] = cube;
            }
    }
    this.setState({cubes});
  }

  // Solves white (front) cross for 3x3 and greater
  solveWhiteCross = () => {
    this.setState({currentFunc : "Solving White Cross"});
    //this.setState({solving : true})
    if(!this.state.canScramble) return;
    let moveString = "";
    let cube = this.state.rubiksObject;
    let space = "";
    let solvedEdges = 0;

    let dim = this.state.cubeDimension;

    if(dim === 2) solvedEdges = 4;

    let pieceOne = Math.floor(dim/2);
    let pieceTwo = dim * pieceOne;
    let pieceThree = pieceTwo + (dim -1);
    let pieceFour = dim * dim - Math.ceil(dim/2);

    for(let i = 0; i < cube.length; i++){
      if(moveString.length) space = " ";
      if(cube[i].includes("white")){

        let emptyCount = 0;
        let whiteSide = -1;
        //let otherSide = -1;
        let cubeX = cube[i][6];
        let cubeY = cube[i][7];
        let cubeZ = cube[i][8];
        

        for(let j = 0; j < 6; j++){
          if (cube[i][j] === "black") emptyCount++;
          else {
            if(cube[i][j] === "white") whiteSide = j;
            //else otherSide = j;
          }
        }

        // If edge piece
        if(emptyCount === 4) {
          if(i===pieceOne && solvedEdges === 0 ){
            //console.log("analyzing piece 1");
            if(cubeX===1 && cubeY===0 && cubeZ===2){
              if(!whiteSide) {solvedEdges++;}
              else moveString+= space + "01U' 01R' 01F'";
              //console.log("1 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===0 && cubeZ===1){
              if(!whiteSide) moveString+= space + "01F'";
              else moveString+= space + "01R 01U";
              //console.log("2 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===0 && cubeZ===0){
              if(!whiteSide) moveString+= space + "01F2";
              else moveString+= space + "01D 01R 01F'";
              //console.log("3 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===0 && cubeZ===1){
              if(!whiteSide) moveString+= space + "01F";// works
              else moveString+= space + "01L' 01U'";// works
              //console.log("4 and whiteside = " + whiteSide); 
            }

            //If piece one is in y section 1
            else if(cubeX===0 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01L 01F";
              else moveString+= space + "01U'";
              //console.log("5 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01R' 01F'";
              else moveString+= space + "01U";
              //console.log("6 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===0){
              if(whiteSide===2) moveString+= space + "01D' 01F2";
              else moveString+= space + "01R 01F'";
              //console.log("7 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===1 && cubeZ===0){
              if(whiteSide===4) moveString+= space + "01D 01F2"; // works
              else moveString+= space + "01L' 01F";
              //console.log("8 and whiteside = " + whiteSide);
            }

            //If piece one is in y section 2
            else if(cubeX===1 && cubeY===2 && cubeZ===2){
              if(whiteSide===3) moveString+= space + "01U2";
              else moveString+= space + "01B 01L 01U'";
              //console.log("9 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01R2 01F'";
              else moveString+= space + "01R' 01U";
              //console.log("10 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===2 && cubeZ===0){
              if(whiteSide===3) moveString+= space + "01B2 01U2";
              else moveString+= space + "01B' 01L 01U'";
              //console.log("11 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01B' 01U2";
              else moveString+= space + "01L 01U'";
              //console.log("12 and whiteside = " + whiteSide);
            }
            //if(this.canQueue(moveString)) return;
          }
          if(i===pieceTwo && solvedEdges === 1){
            //console.log("analyzing piece 3");
            
            if(cubeX===0 && cubeY===0 && cubeZ===1){
              if(!whiteSide) {solvedEdges++;}
              else moveString+= space + "01L' 01R 01U' 01R'";
              //console.log("piece (3) 1 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===0 && cubeZ===0){
              if(!whiteSide) moveString+= space + "01D' 01F' 01D 01F";
              else moveString+= space + "01D' 01L'";
              //console.log("5.3 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===0 && cubeZ===1){
              if(!whiteSide) moveString+= space + "01R 01F2 01R' 01F2";// works
              else moveString+= space + "01R 01F 01U 01F'";// works
              //console.log("5.4 and whiteside = " + whiteSide); 
            }

            //If piece three is in y section 1
            if(cubeX===0 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01L";
              else moveString+= space + "01F 01U' 01F'";
              //console.log("5 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01F2 01R' 01F2";
              else moveString+= space + "01U 01F' 01U'";
              //console.log("6 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===0){
              if(whiteSide===2) moveString+= space + "01F' 01D' 01F";
              else moveString+= space + "01F2 01R 01F2";
              //console.log("7 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===1 && cubeZ===0){
              if(whiteSide===4) moveString+= space + "01F' 01D 01F"; // works
              else moveString+= space + "01L'";
              //console.log("8 and whiteside = " + whiteSide);
            }

            //If piece one is in y section 2
            if(cubeX===1 && cubeY===2 && cubeZ===2){
              if(whiteSide===3) moveString+= space + "01F 01U2 01F'";
              else moveString+= space + "01U' 01L 01U";
              //console.log("9 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01B2 01L2";
              else moveString+= space + "01R' 01F 01U 01F'";
              //console.log("10 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===2 && cubeZ===0){
              if(whiteSide===3) moveString+= space + "01F' 01D2 01F";
              else moveString+= space + "01D 01L'";
              //console.log("11 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01L2";
              else moveString+= space + "01B' 01U' 01L 01U";
              //console.log("12 and whiteside = " + whiteSide);
            }
            //if(this.canQueue(moveString)) return;*/
            //continueSolve = !continueSolve;
          }
          if(i===pieceThree && solvedEdges === 2){
            //console.log("analyzing piece 5");
  
            if(cubeX===1 && cubeY===0 && cubeZ===0){
              if(!whiteSide) moveString+= space + "01D 01F 01D' 01F'";
              else moveString+= space + "01D 01R";
              //console.log("5.3 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===0 && cubeZ===1){
              if(!whiteSide) {solvedEdges++;}
              else moveString+= space + "01R 01F' 01U 01F";// works
              //console.log("5.4 and whiteside = " + whiteSide); 
            }
            
            //If piece three is in y section 1
            if(cubeX===0 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01F2 01L 01F2";
              else moveString+= space + "01F' 01U' 01F";
              //console.log("5 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01R'";
              else moveString+= space + "01F' 01U 01F";
              //console.log("6 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===0){
              if(whiteSide===2) moveString+= space + "01F 01D' 01F'";
              else moveString+= space + "01R";
              //console.log("7 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===1 && cubeZ===0){
              if(whiteSide===4) moveString+= space + "01F 01D 01F'"; // works
              else moveString+= space + "01F2 01L' 01F2";
              //console.log("8 and whiteside = " + whiteSide);
            }

            //If piece one is in y section 2
            if(cubeX===1 && cubeY===2 && cubeZ===2){
              if(whiteSide===3) moveString+= space + "01F' 01U2 01F";
              else moveString+= space + "01U 01R' 01U'";
              //console.log("9 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01R2";
              else moveString+= space + "01R' 01F' 01U 01F";
              //console.log("10 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===2 && cubeZ===0){
              if(whiteSide===3) moveString+= space + "01F 01D2 01F'";
              else moveString+= space + "01D' 01L";
              //console.log("11 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01B2 01R2";
              else moveString+= space + "01B' 01U 01R' 01U'";
              //console.log("12 and whiteside = " + whiteSide);
            }
          }
          if(i===pieceFour && solvedEdges === 3){
            //console.log("analyzing piece 7");
  
            if(cubeX===1 && cubeY===0 && cubeZ===0){
              if(!whiteSide) {solvedEdges++;}
              else moveString+= space + "01D 01F' 01R 01F";
              //console.log("5.3 and whiteside = " + whiteSide);
            }
            
            //If piece three is in y section 1
            if(cubeX===0 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01F 01L 01F'";
              else moveString+= space + "01F2 01U' 01F2";
              //console.log("5 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===2){
              if(whiteSide===1) moveString+= space + "01F' 01R' 01F";
              else moveString+= space + "01F2 01U 01F2";
              //console.log("6 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===1 && cubeZ===0){
              if(whiteSide===2) moveString+= space + "01D'";
              else moveString+= space + "01F' 01R 01F";
              //console.log("7 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===1 && cubeZ===0){
              if(whiteSide===4) moveString+= space + "01D"; // works
              else moveString+= space + "01F 01L' 01F'";
              //console.log("8 and whiteside = " + whiteSide);
            }

            //If piece one is in y section 2
            if(cubeX===1 && cubeY===2 && cubeZ===2){
              if(whiteSide===3) moveString+= space + "01F2 01U2 01F2";
              else moveString+= space + "01B 01L' 01D 01L";
              //console.log("9 and whiteside = " + whiteSide);
            }
            else if(cubeX===2 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01F' 01R2 01F";
              else moveString+= space + "01R 01D' 01R'";
              //console.log("10 and whiteside = " + whiteSide);
            }
            else if(cubeX===1 && cubeY===2 && cubeZ===0){
              if(whiteSide===3) moveString+= space + "01D2";
              else moveString+= space + "01D' 01F' 01R 01F";
              //console.log("11 and whiteside = " + whiteSide);
            }
            else if(cubeX===0 && cubeY===2 && cubeZ===1){
              if(whiteSide===3) moveString+= space + "01F 01L2 01F'";
              else moveString+= space + "01L' 01D 01L";
              //console.log("12 and whiteside = " + whiteSide);
            }
          }
        }
      }
    }
    
    
    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(solvedEdges < 4){
      this.moveSetTimed(moveArray,moveArray.length-1,0,1);
    }
    else {
      this.solveWhiteCorners();
    }
  }

  // Solves white (front) corners
  solveWhiteCorners = () => {
    this.setState({currentFunc : "Solving White Corners"});
    let moveString = "";
    let cube = this.state.rubiksObject;
    let space = "";
    let solvedCorners = 0;

    let dim = this.state.cubeDimension;

    let pieceOne = 0;
    let pieceTwo = dim - 1;
    let pieceThree = (cube.length/dim) - dim;
    let pieceFour = (cube.length/dim) - 1;

    for(let i = 0; i < cube.length; i++){
      if(moveString.length) space = " ";
      if(cube[i].includes("white")){

        let emptyCount = 0;
        let whiteSide = -1;
        //let otherSide = -1;
        let cubeX = cube[i][6];
        let cubeY = cube[i][7];
        let cubeZ = cube[i][8];
        

        for(let j = 0; j < 6; j++){
          if (cube[i][j] === "black") emptyCount++;
          else {
            if(cube[i][j] === "white") whiteSide = j;
            //else otherSide = j;
          }
        }

        // If edge piece
        if(emptyCount === 3) {

          if(i===pieceOne && solvedCorners === 0 ){
            //Front
            if(cubeX===0 && cubeY===0 && cubeZ===dim-1){
              if(whiteSide===0){solvedCorners++;}
              else if(whiteSide===1) moveString+= space + "01L' 01B 01L 01B' 01L' 01B 01L";
              else moveString+= space + "01L' 01B' 01L 01B2 01U 01B' 01U'";
            }
            else if(cubeX===dim-1 && cubeY===0 && cubeZ===dim-1) moveString+= space + "01R 01L' 01B 01L 01R'"
            else if(cubeX===dim-1 && cubeY===0 && cubeZ===0) moveString+= space + "01R' 01B' 01R 01U 01B' 01U'";
            else if(cubeX===0 && cubeY===0 && cubeZ===0) moveString+= space + "01D' 01U 01B 01U' 01D"
            //Back
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01U 01B 01U'"
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01L' 01B 01L"
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01L' 01B2 01L"
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01U 01B' 01U'"
          }

          if(i===pieceTwo && solvedCorners === 1 ){
            if(cubeX===dim-1 && cubeY === 0 && cubeZ === dim-1){
              if(whiteSide === 0){solvedCorners++}
              else if(whiteSide===1) moveString += space + "01R 01B' 01R' 01B 01R 01B' 01R'";
              else moveString += space + "01U' 01B 01U 01B' 01U' 01B 01U";
            }
            else if(cubeX === dim-1 && cubeY===0 && cubeZ===0) moveString+= space + "01U' 01D 01B 01D' 01U";
            else if(cubeX===0 && cubeY===0 && cubeZ===0) moveString+= space + "01L 01R 01B2 01R' 01L'";
            //Back
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01R 01B' 01R'";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01B 01R 01B' 01R'";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01B2 01R 01B' 01R'";
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01R 01B2 01R'";
          }

          if(i===pieceThree && solvedCorners === 2 ){
            if(cubeX===0 && cubeY===0 && cubeZ===0){
              if(whiteSide === 0){solvedCorners++}
              else if(whiteSide === 4) moveString += space + "01D' 01B 01D 01B' 01D' 01B 01D";
              else moveString += space + "01L 01B' 01L' 01B 01L 01B' 01L'";
            }
            else if(cubeX === dim-1 && cubeY===0 && cubeZ===0) moveString+= space + "01R' 01L 01B' 01L' 01R";
            //Back
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01D' 01B 01D";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01D' 01B2 01D";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01B' 01D' 01B' 01D";
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01D' 01B' 01D";
          }

          if(i===pieceFour && solvedCorners === 3 ){
            if(cubeX === dim-1 && cubeY===0 && cubeZ===0){
              if(whiteSide === 0){solvedCorners++}
              else if(whiteSide === 2) moveString += space + "01D 01B' 01D' 01B 01D 01B' 01D'";
              else moveString += space + "01R' 01B 01R 01B' 01R' 01B 01R";
            }
            //Back
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + " 01R' 01B2 01R";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===dim-1) moveString+= space + "01D 01B' 01D'";
            else if(cubeX===dim-1 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01B 01D 01B' 01D'";
            else if(cubeX===0 && cubeY===dim-1 && cubeZ===0) moveString+= space + "01R' 01B 01R";
          }
        }
      }
    }

    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(solvedCorners < 4){
      this.moveSetTimed(moveArray,moveArray.length-1,0,2);
    }
    else{
      if(dim < 3) this.alignYellowCorners();
      else this.solveMiddleEdges();
    }
  }

  // Correctly positions the middle edges for 3x3 and greater
  solveMiddleEdges = () => {
    this.setState({currentFunc : "Solving Midde Edges"});
    let moveString = "";
    let cube = this.state.rubiksObject;
    let space = "";
    let solvedEdges = 0;
    let moveFromMiddle012 = "01B 01U 01B' 01U' 01B' 01L' 01B 01L";
    let moveFromMiddle212 = "01B 01R 01B' 01R' 01B' 01U' 01B 01U";
    let moveFromMiddle210 = "01B 01D 01B' 01D' 01B' 01R' 01B 01R";
    let moveFromMiddle010 = "01B 01L 01B' 01L' 01B' 01D' 01B 01D";

    for(let i = 0; i < 27; i++){
      if(moveString.length) space = " ";
      if(cube[i].includes("green") || cube[i].includes("blue")){
        let emptyCount = 0;
        let blueSide = -1;
        let greenSide = -1;
        let cubeX = cube[i][6];
        let cubeY = cube[i][7];
        let cubeZ = cube[i][8];

        for(let j = 0; j < 6; j++){
          if (cube[i][j] === "black") emptyCount++;
          else {
            if(cube[i][j] === "blue") blueSide = j;
            else if(cube[i][j] === "green") greenSide = j;
          }
        }

        if(emptyCount === 4){
          if(i===9 && solvedEdges === 0){
            //Front
            if(cubeX === 0 && cubeY === 1 && cubeZ === 2){
              if(blueSide === 1){solvedEdges++;}
              else moveString+= space + moveFromMiddle012;
            }
            else if(cubeX === 2 && cubeY === 1 && cubeZ === 2) moveString+= space + moveFromMiddle212;
            else if(cubeX === 0 && cubeY === 1 && cubeZ === 0) moveString+= space + moveFromMiddle010;
            else if(cubeX === 2 && cubeY === 1 && cubeZ === 0) moveString+= space + moveFromMiddle210;
            //Back
            else if(cubeX === 0 && cubeY === 2 && cubeZ === 1) {
              if(blueSide === 3) moveString+= space + moveFromMiddle012;
              else moveString+= space + "01B2 01L' 01B' 01L 01B 01U 01B 01U'";
            }
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 2) moveString+= space + "01B";
            else if(cubeX === 2 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B2";
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 0) moveString+= space + "01B'";
          }
          if(i===11 && solvedEdges === 1){
            //Front
            if(cubeX === 2 && cubeY === 1 && cubeZ === 2){
              if(blueSide === 1){solvedEdges++;}
              else moveString+= space + moveFromMiddle212;
            }
            else if(cubeX === 0 && cubeY === 1 && cubeZ === 0) moveString+= space + moveFromMiddle010;
            else if(cubeX === 2 && cubeY === 1 && cubeZ === 0) moveString+= space + moveFromMiddle210;
            //Back
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 2) {
              if(blueSide === 1) moveString+= space + moveFromMiddle212;
              else moveString+= space + "01B2 01U' 01B' 01U 01B 01R 01B 01R'";
            }
            else if(cubeX === 2 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B";
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 0) moveString+= space + "01B2";
            else if(cubeX === 0 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B'";
          }
          if(i===15 && solvedEdges === 2){
            //Front
            if(cubeX === 0 && cubeY === 1 && cubeZ === 0){
              if(greenSide === 5){solvedEdges++;}
              else moveString+= space + moveFromMiddle010;
            }
            else if(cubeX === 2 && cubeY === 1 && cubeZ === 0) moveString+= space + moveFromMiddle210;
            //Back
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 0){
              if(greenSide === 5) moveString+= space + moveFromMiddle010;
              else moveString+= space + "01B2 01D' 01B' 01D 01B 01L 01B 01L'";
            }
            else if(cubeX === 0 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B";
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 2) moveString+= space + "01B2";
            else if(cubeX === 2 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B'";
          }
          if(i===17 && solvedEdges === 3){
            //Front
            if(cubeX === 2 && cubeY === 1 && cubeZ === 0){
              if(greenSide === 5){solvedEdges++;}
              else moveString+= space + moveFromMiddle210;
            }
            //Back
            else if(cubeX === 2 && cubeY === 2 && cubeZ === 1){
              if(greenSide === 3) moveString+= space + moveFromMiddle210;
              else moveString+= space + "01B2 01R' 01B' 01R 01B 01D 01B 01D'";
            }
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 0) moveString+= space + "01B";
            else if(cubeX === 0 && cubeY === 2 && cubeZ === 1) moveString+= space + "01B2";
            else if(cubeX === 1 && cubeY === 2 && cubeZ === 2) moveString+= space + "01B'"; 
          }
        }
      }
    }

    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(solvedEdges < 4){
      this.moveSetTimed(moveArray,moveArray.length-1,0,3);
    }
    else{
      this.solveYellowCross();
    }
  }

  // Solves the yellow (back) cross for 3x3 and greater
  solveYellowCross = () => {
    this.setState({currentFunc : "solving yellow cross"});
    let moveString = "";
    let cube = this.state.rubiksObject;
    let recipe = "01U 01R 01B 01R' 01B' 01U'";
    let cubeIndex = [19,21,23,25];
    let cubeAtIndex = [];

    for(let i = 0; i < 4; i++){
      if(cube[cubeIndex[i]][6] === 1 && 
         cube[cubeIndex[i]][7] === 2 &&
         cube[cubeIndex[i]][8] === 2) cubeAtIndex[0] = cube[cubeIndex[i]][3];
      else if (cube[cubeIndex[i]][6] === 0 && 
        cube[cubeIndex[i]][7] === 2 &&
        cube[cubeIndex[i]][8] === 1) cubeAtIndex[1] = cube[cubeIndex[i]][3];
      else if (cube[cubeIndex[i]][6] === 2 && 
        cube[cubeIndex[i]][7] === 2 &&
        cube[cubeIndex[i]][8] === 1) cubeAtIndex[2] = cube[cubeIndex[i]][3];
      else if (cube[cubeIndex[i]][6] === 1 && 
        cube[cubeIndex[i]][7] === 2 &&
        cube[cubeIndex[i]][8] === 0) cubeAtIndex[3] = cube[cubeIndex[i]][3];
    }

    //console.log(cubeAtIndex[0],cubeAtIndex[1],cubeAtIndex[2],cubeAtIndex[3]);
    if(cube[19][3] === "yellow" &&
      cube[21][3] === "yellow" &&
      cube[23][3] === "yellow" &&
      cube[25][3] === "yellow" 
      ) ;//console.log("Cross already solved");

    //Line
    else if (cubeAtIndex[0] === "yellow" && cubeAtIndex[3] === "yellow" ) {moveString = "01B " + recipe;}
    else if (cubeAtIndex[1] === "yellow" && cubeAtIndex[2] === "yellow" ) {moveString = recipe;}

    //L-Shape
    else if (cubeAtIndex[0] === "yellow" && cubeAtIndex[2] === "yellow" ) {moveString = "01B2 " + recipe + " " + recipe;}
    else if (cubeAtIndex[1] === "yellow" && cubeAtIndex[3] === "yellow" ) {moveString = recipe + " " + recipe;}
    else if (cubeAtIndex[0] === "yellow" && cubeAtIndex[1] === "yellow" ) {moveString = "01B " + recipe + " " + recipe;}
    else if (cubeAtIndex[2] === "yellow" && cubeAtIndex[3] ) {moveString = "01B' " + recipe + " " + recipe;}

    else moveString = recipe;
    
    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(moveString.length){
      this.moveSetTimed(moveArray,moveArray.length-1,0,4);
    }
    else{
      this.alignYellowCross();
    }
  }

  // Aligns the yellow (back) cross
  alignYellowCross = () =>{
    this.setState({currentFunc : "Aligning Yellow Edges"});
    let moveString = "";
    let cube = this.state.rubiksObject;

    if(cube[19][6] === 1 && cube[19][7] === 2 && cube[19][8] === 2){
      //Check if other pieces are in place
      if(cube[21][6] === 0 && cube[21][8] === 1 &&
         cube[23][6] === 2 && cube[23][8] === 1);// console.log("top aligned");

      else if(cube[21][6] === 2 && cube[23][8] === 1 &&
              cube[25][6] === 1 && cube[25][8] === 0) moveString = "01D 01B 01D' 01B 01D 01B2 01D' 01B2 01L 01B 01L' 01B 01L 01B2 01L' 01B";

      else if(cube[25][6] === 2 && cube[25][8] === 1) moveString = "01R 01B 01R' 01B 01R 01B2 01R' 01B";

      else if(cube[25][6] === 0 && cube[25][8] === 1) moveString = "01R 01B 01R' 01B 01R 01B2 01R' 01B";


      //Make moves
    }
    else if(cube[19][6] === 2 && cube[19][7] === 2 && cube[19][8] === 1){
      moveString = "01B";
    }
    else moveString = "01B'"

    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(moveString.length){
      this.moveSetTimed(moveArray,moveArray.length-1,0,5);
    }
    else{
      this.alignYellowCorners();
    }
  }

  // Aligns the yellow (back) corners
  alignYellowCorners = () =>{
    this.setState({currentFunc : "Aligning Yellow Corners"});
    let moveString = "";
    let cube = this.state.rubiksObject;

    let dim = this.state.cubeDimension;

    let pieceOne = cube.length - (dim*dim);
    let pieceTwo = pieceOne + (dim-1);
    let pieceThree = cube.length - dim;
    let pieceFour = cube.length - 1;


    if(cube[pieceOne][6] === 0 && cube[pieceOne][8] === dim-1 &&
       cube[pieceTwo][6] === dim-1 && cube[pieceTwo][8] === dim-1);// console.log("corners aligned");

    else if(cube[pieceOne][6] === 0 && cube[pieceOne][8] === dim-1) moveString = "01B 01U 01B' 01D' 01B 01U' 01B' 01D";
    else if(cube[pieceTwo][6] === dim-1 && cube[pieceTwo][8] === dim-1) moveString = "01B 01R 01B' 01L' 01B 01R' 01B' 01L";
    else if(cube[pieceThree][6] === 0 && cube[pieceThree][8] === 0) moveString = "01B 01L 01B' 01R' 01B 01L' 01B' 01R";
    else if(cube[pieceFour][6] === dim-1 && cube[pieceFour][8] === 0) moveString = "01B 01D 01B' 01U' 01B 01D' 01B' 01U";

    else moveString = "01B 01U 01B' 01D' 01B 01U' 01B' 01D";

    const moveArray = this.moveStringToArray(moveString);
    //console.log(moveArray);

    if(moveString.length){
      this.moveSetTimed(moveArray,moveArray.length-1,0,6);
    }
    else{
      let scope = this;
      this.solveYellowCorners(scope);
    }
  }

  // Solves the yellow (back) corners
  solveYellowCorners(scope){
    //console.log(scope);
    scope.setState({currentFunc : "Solving Yellow Corners"});
    let moveString = "";
    let cube = scope.state.rubiksObject;
    
    let dim = scope.state.cubeDimension;

    let pieceOne = cube.length - (dim*dim);
    let pieceTwo = pieceOne + (dim-1);
    let pieceThree = cube.length - dim;
    let pieceFour = cube.length - 1;

    if(cube[pieceOne][3] === "yellow" &&
       cube[pieceTwo][3] === "yellow" &&
       cube[pieceThree][3] === "yellow" &&
       cube[pieceFour][3] === "yellow"){
      //console.log(cube[pieceOne])
      if(cube[pieceOne][6] === 0 && cube[pieceOne][8] === dim-1);
        //console.log("yellow corners solved");
      else moveString = "01B";
    }
    else if(cube[pieceOne][3]!== "yellow"){
      //console.log("cube[pieceOne]");
      moveString = "01U' 01F' 01U 01F 01U' 01F' 01U 01F";
    }
    else if(cube[pieceTwo][3]!== "yellow"){
      //console.log(cube[pieceTwo]);
      if(cube[pieceTwo][6] === 0 && cube[pieceTwo][8] === dim-1) {
        //console.log("cube[pieceTwo]");
        moveString = "01U' 01F' 01U 01F 01U' 01F' 01U 01F";
      }
      else {
        moveString = "01B";
      }
    }
    else if(cube[pieceFour][3]!== "yellow"){
      //console.log(cube[pieceFour]);
      if(cube[pieceFour][6] === 0 && cube[pieceFour][8] === dim-1) {
        //console.log("cube[pieceFour]");
        moveString = "01U' 01F' 01U 01F 01U' 01F' 01U 01F";
      }
      else{
        moveString = "01B";
      }
    }
    else if(cube[pieceThree][3]!== "yellow"){
      //console.log(cube[pieceThree][6],cube[pieceThree][8]);
      if(cube[pieceThree][6] === 0 && cube[pieceThree][8] === dim-1) {
        //console.log("cube[pieceThree]");
        moveString = "01U' 01F' 01U 01F 01U' 01F' 01U 01F";
      }
      else {
        moveString = "01B";
      }
    }

    let moveArray = scope.moveStringToArray(moveString);
    //console.log(moveArray);

    if(moveString.length){
      scope.moveSetTimed(moveArray,moveArray.length-1,0,7);
    }
    else{
      if(dim === 2) {
        //console.log("checking for anomoly");
        //console.log(cube[pieceOne]);
        if(cube[pieceOne][6]===0 && cube[pieceOne][8]===dim-1) {
          //console.log("piece one is positioned correctly");
          if(cube[pieceTwo][6]===dim-1 && cube[pieceTwo][8]===dim-1){
            //console.log("piece two is positioned correctly");
            if(cube[pieceThree][6]===0 && cube[pieceThree][8]===0){
              //console.log("Solved!")
              scope.setState({moveLog : "",currentFunc: "none"});
            }
            else {
              //console.log("Anomoly found! Solution: ");
              moveString = "01R 01D' 01R' 01F' 01R' 01F 01D";
              moveArray = scope.moveStringToArray(moveString);
              //console.log(moveArray);
              scope.moveSetTimed(moveArray,moveArray.length-1,0,7);
            }
          }
        }
        else {
          moveString = "01B";
          moveArray = scope.moveStringToArray(moveString);
          //console.log(moveArray);
          scope.moveSetTimed(moveArray,moveArray.length-1,0,7);
        }
      }

      // else
      else {
        //console.log("Solved!");
        scope.setState({moveLog : "",currentFunc: "none"});
      }
    }
  }

  // Remove event listener on compenent unmount	
  componentWillUnmount() {    
    window.removeEventListener("keydown", this.keyHandling);
  }

  // Gets the url to be parsed
  getUrlVars() {
    var vars = {};
    var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
        vars[key] = value;
    });
    return parts;
  }

  // Initialization and animation functions
  componentDidMount() {
    let url = this.getUrlVars();
    let cD;
    if(url.length < 30) cD = parseInt(url.substring(25));
    else cD = parseInt(url.substring("http://mighty-fortress-00882.herokuapp.com/id=".length+1));
    if(cD <= 20 || cD >= 2);
    else cD = 3;
    this.setState({cubeDimension : cD});
    
    let rubiksObject = this.generateSolved(cD,cD,cD);
    this.setState({rubiksObject : rubiksObject});
    window.addEventListener("keydown", this.keyHandling);

    // === THREE.JS CODE START ===
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, .1, 1000 );
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(new THREE.Color(0,0,0),1);
    renderer.setSize( window.innerWidth, window.innerHeight-10);
    document.body.appendChild( renderer.domElement );
    
    let tempCubes = [];
    // generate cubes with face colors based off rubiksObject
    for(let i = 0; i < rubiksObject.length; i++){

      let cubeX = rubiksObject[i][6];
      let cubeY = rubiksObject[i][7];
      let cubeZ = rubiksObject[i][8];

      var geometry = new THREE.BoxGeometry( .95, .95, .95 );
      var cubeMaterials = [ 
        new THREE.MeshBasicMaterial({color:rubiksObject[i][2], opacity:0.8, side: THREE.DoubleSide}),
        new THREE.MeshBasicMaterial({color:rubiksObject[i][4], opacity:0.8, side: THREE.DoubleSide}), 
        new THREE.MeshBasicMaterial({color:rubiksObject[i][3], opacity:0.8, side: THREE.DoubleSide}),
        new THREE.MeshBasicMaterial({color:rubiksObject[i][0], opacity:0.8, side: THREE.DoubleSide}), 
        new THREE.MeshBasicMaterial({color:rubiksObject[i][1], opacity:0.8, side: THREE.DoubleSide}), 
        new THREE.MeshBasicMaterial({color:rubiksObject[i][5], opacity:0.8, side: THREE.DoubleSide}), 
      ]; 
      var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
    
      tempCubes[i] = new THREE.Mesh(geometry, cubeMaterial);
      
      tempCubes[i].translateX(cubeX);
      tempCubes[i].translateY(cubeY /*+ offSetY*/);
      tempCubes[i].translateZ(cubeZ); 
    }

    // add cubes to state and then render
    this.setState({cubes : tempCubes}, () => {
      for(let i = 0; i < rubiksObject.length; i++){
        if((this.state.cubes[i].position.x === 0 || this.state.cubes[i].position.x === this.state.cubeDimension-1) ||
            (this.state.cubes[i].position.y === 0 || this.state.cubes[i].position.y === this.state.cubeDimension-1)||
            (this.state.cubes[i].position.z === 0 || this.state.cubes[i].position.z === this.state.cubeDimension-1)){

          scene.add( this.state.cubes[i] );

          //Add outlines to each piece
          let geo = new THREE.EdgesGeometry(this.state.cubes[i].geometry);
          let mat = new THREE.LineBasicMaterial({
            color : 0x000000, linewidth: 1
          });
          let wireframe = new THREE.LineSegments(geo,mat);
          wireframe.renderOrder = 1;
          this.state.cubes[i].add(wireframe);
        } 
      }
      renderer.render( scene, camera );
      animate();
    });

    let rotate = this.rotatePoint;
    
    // Function runs continuously to animate cube
    var animate = () => {
      let centerPoint = this.state.cubeDimension/2-.5;
      camera.position.z = this.state.cameraZ * Math.sin( this.state.angle );
      camera.position.y = this.state.cameraY;
      camera.position.x = this.state.cameraX * Math.cos( this.state.angle );
      camera.lookAt(new THREE.Vector3( 1, 1, 1 ));
      requestAnimationFrame( animate );
      
      if(this.state.start<=this.state.end){
        // state variables asigned for shorter names
        let cubes = this.state.cubes;
        let turnDirection = this.state.turnDirection;
        let speed = this.state.speed;
        let start = this.state.start;
        let face = this.state.face;
        let cubeDepth = this.state.cubeDepth;

        this.setState({start : start+speed});

        //Rotate white center piece Face
        if(face === 0){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(cubes[i].position.y > -1 && cubes[i].position.y < cubeDepth){
              
              // Turn piece based on rotation direction
              if(turnDirection<0){
                cubes[i].rotation.y += .1745*speed/10;
              }
              else {
                cubes[i].rotation.y -= .1745*speed/10;
              }

              // Calculate circular movement
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,cubes[i].position.x,cubes[i].position.z,speed);

              // corrects rounding errors
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              
              // set new locations for face 0
              cubes[i].position.x = newPoint.p1;
              cubes[i].position.z = newPoint.p2;
            }
          }     
        }
        // blue
        if(face === 1){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(cubes[i].position.z < this.state.cubeDimension && cubes[i].position.z > this.state.cubeDimension - 1 - cubeDepth){
              if(turnDirection<0)
                cubes[i].rotation.z -= .1745*speed/10;
              else 
                cubes[i].rotation.z += .1745*speed/10;
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,cubes[i].position.x,cubes[i].position.y,10*speed/10);
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              cubes[i].position.x = newPoint.p1;
              cubes[i].position.y = newPoint.p2;
            }
          }
        }
        // red
        if(face === 2){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(tempCubes[i].position.x < this.state.cubeDimension && cubes[i].position.x > this.state.cubeDimension - 1 - cubeDepth){
              if(turnDirection<0)
                tempCubes[i].rotation.x -= .1745*speed/10;
              else 
                tempCubes[i].rotation.x += .1745*speed/10;
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,tempCubes[i].position.y,tempCubes[i].position.z,10*speed/10);
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              tempCubes[i].position.y = newPoint.p1;
              tempCubes[i].position.z = newPoint.p2;
            }
          }
        }
        // yellow
        if(face === 3){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(tempCubes[i].position.y < this.state.cubeDimension && cubes[i].position.y > this.state.cubeDimension - 1 - cubeDepth){
              if(turnDirection<0)
                tempCubes[i].rotation.y += .1745*speed/10;
              else 
                tempCubes[i].rotation.y -= .1745*speed/10;
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,tempCubes[i].position.x,tempCubes[i].position.z,10*speed/10);
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              tempCubes[i].position.x = newPoint.p1;
              tempCubes[i].position.z = newPoint.p2;
            }
          }
        }
        // orange
        if(face === 4){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(tempCubes[i].position.x > -1 && cubes[i].position.x < cubeDepth){
              if(turnDirection<0)
                tempCubes[i].rotation.x -= .1745*speed/10;
              else 
                tempCubes[i].rotation.x += .1745*speed/10;
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,tempCubes[i].position.y,tempCubes[i].position.z,10*speed/10);              
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              tempCubes[i].position.y = newPoint.p1;
              tempCubes[i].position.z = newPoint.p2;
            }
          }
        }
        // green
        if(face === 5){
          for(let i = 0; i<this.state.rubiksObject.length;i++){
            if(tempCubes[i].position.z > -1 && cubes[i].position.z < cubeDepth){
              if(turnDirection<0)
                tempCubes[i].rotation.z -= .1745*speed/10;
              else 
                tempCubes[i].rotation.z += .1745*speed/10;
              let newPoint = rotate(centerPoint,centerPoint,turnDirection,tempCubes[i].position.x,tempCubes[i].position.y,10*speed/10);
              if(start % 90 === 0){
                newPoint.p1 = Math.round(newPoint.p1);
                newPoint.p2 = Math.round(newPoint.p2);
              }
              tempCubes[i].position.x = newPoint.p1;
              tempCubes[i].position.y = newPoint.p2;
            }
          }
        } 
      }
      renderer.render( scene, camera );     
    };
  }

  // Renders html to the index.html page
  render() {
    return (
      <div className="App" >
        <Navbar
        title="Rubik's Cube"
        />
        
        <p style={{position:"fixed", top: "75px", left: "10px",color: "white"}}>Speed: {this.state.rotationSpeed}</p>
        <p style={{position:"fixed", top: "75px", right: "10px",color: "white"}}>Current Function: {this.state.currentFunc}</p>

        {/* Top Left */}
        <button onClick={this.increaseSpeed} style={{position:"fixed", top: "100px", left: "10px",backgroundColor: "white"}}>+ Speed</button>
        <button onClick={this.decreaseSpeed} style={{position:"fixed", top: "130px", left: "10px",backgroundColor: "white"}}>- Speed</button>
        
        {/* Bottom Left */}
        <button onClick={this.cross} style={{position:"fixed", bottom: "160px", left: "10px",backgroundColor: "white"}}>Cross</button>
        <button onClick={this.checkerBoard} style={{position:"fixed", bottom: "130px", left: "10px",backgroundColor: "white"}}>Checkerboard</button>
        <button onClick={this.checkerBoard1} style={{position:"fixed", bottom: "100px", left: "10px",backgroundColor: "white"}}>Checkerboard1</button>
        <button onClick={this.cubeIn} style={{position:"fixed", bottom: "70px", left: "10px",backgroundColor: "white"}}>Cube x2</button>
        <button onClick={this.cubeInACube} style={{position:"fixed", bottom: "40px", left: "10px",backgroundColor: "white"}}>Cube x3</button>
        <button onClick={this.sixSpots} style={{position:"fixed", bottom: "10px", left: "10px",backgroundColor: "white"}}>Six Spots</button>
        
        {/* Top Right */}
        <button onClick={this.rzl} style={{position:"fixed", top: "100px", right: "50px",backgroundColor: "white"}}>F'</button>
        <button onClick={this.rzr} style={{position:"fixed", top: "100px", right: "10px",backgroundColor: "white"}}>F</button>
        <button onClick={this.rol} style={{position:"fixed", top: "140px", right: "50px",backgroundColor: "blue",color: "white"}}>U'</button>
        <button onClick={this.ror} style={{position:"fixed", top: "140px", right: "10px",backgroundColor: "blue",color: "white"}}>U</button>
        <button onClick={this.rtwl} style={{position:"fixed", top: "180px", right: "50px",backgroundColor: "red",color: "white"}}>R'</button>
        <button onClick={this.rtwr} style={{position:"fixed", top: "180px", right: "10px",backgroundColor: "red",color: "white"}}>R</button>
        <button onClick={this.rthl} style={{position:"fixed", top: "220px", right: "50px",backgroundColor: "yellow"}}>B'</button>
        <button onClick={this.rthr} style={{position:"fixed", top: "220px", right: "10px",backgroundColor: "yellow"}}>B</button>
        <button onClick={this.rfol} style={{position:"fixed", top: "260px", right: "50px",backgroundColor: "orange"}}>L'</button> 
        <button onClick={this.rfor} style={{position:"fixed", top: "260px", right: "10px",backgroundColor: "orange"}}>L</button>
        <button onClick={this.rfil} style={{position:"fixed", top: "300px", right: "50px",backgroundColor: "green",color: "white"}}>D'</button> 
        <button onClick={this.rfir} style={{position:"fixed", top: "300px", right: "10px",backgroundColor: "green",color: "white"}}>D</button>

        {/* Bottom Right */} 
        <button onClick={this.solveWhiteCross} style={{position:"fixed", bottom: "100px", right: "10px",backgroundColor: "white"}}>SOLVE</button>
        <button onClick={this.scramble} style={{position:"fixed", bottom: "70px", right: "10px",backgroundColor: "white"}}>SCRAMBLE</button>
        <button onClick={this.reverseMoves} style={{position:"fixed", bottom: "40px", right: "10px",backgroundColor: "white"}}>Reverse Moves</button>
        <button onClick={this.reset} style={{position:"fixed", bottom: "10px", right: "10px",backgroundColor: "white"}}>RESET</button>
      </div>
    );
  }
}

export default App;